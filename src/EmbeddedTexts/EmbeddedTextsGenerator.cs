using Microsoft.CodeAnalysis;
using PodNet.Analyzers.CodeAnalysis;
using System.Text;

namespace PodNet.EmbeddedTexts;

[Generator(LanguageNames.CSharp)]
public sealed class EmbeddedTextsGenerator : IIncrementalGenerator
{
    public const string EmbedAdditionalTextsConfigProperty = "PodNetAutoEmbedAdditionalTexts";
    public const string EmbedTextMetadataProperty = "PodNet_EmbedText";
    public const string EmbedTextNamespaceMetadataProperty = "PodNet_EmbedTextNamespace";
    public const string EmbedTextClassNameMetadataProperty = "PodNet_EmbedTextClassName";
    public const string EmbedTextIsConstMetadataProperty = "PodNet_EmbedTextIsConst";
    public const string EmbedTextIdentifierMetadataProperty = "PodNet_EmbedTextIdentifier";

    public record EmbeddedTextItemOptions(
        string? RootNamespace,
        string? ProjectDirectory,
        string? ItemNamespace,
        string? ItemClassName,
        bool? IsConst,
        string? Identifier,
        bool Enabled,
        AdditionalText Text);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var allTexts = context.AdditionalTextsProvider.Combine(context.AnalyzerConfigOptionsProvider)
            .Select((item, _) =>
            {
                var (text, options) = item;
                var itemOptions = options.GetOptions(text);
                var globalEnabled = string.Equals(options.GlobalOptions.GetBuildProperty(EmbedAdditionalTextsConfigProperty) ?? "true", "true", StringComparison.OrdinalIgnoreCase);
                var itemSwitch = itemOptions.GetAdditionalTextMetadata(EmbedTextMetadataProperty);
                var itemEnabled = string.Equals(itemSwitch, "true", StringComparison.OrdinalIgnoreCase);
                var itemDisabled = string.Equals(itemSwitch, "false", StringComparison.OrdinalIgnoreCase);
                return new EmbeddedTextItemOptions(
                    RootNamespace: options.GlobalOptions.GetRootNamespace(),
                    ProjectDirectory: options.GlobalOptions.GetProjectDirectory(),
                    ItemNamespace: itemOptions.GetAdditionalTextMetadata(EmbedTextNamespaceMetadataProperty),
                    ItemClassName: itemOptions.GetAdditionalTextMetadata(EmbedTextClassNameMetadataProperty),
                    IsConst: string.Equals(itemOptions.GetAdditionalTextMetadata(EmbedTextIsConstMetadataProperty), "true", StringComparison.OrdinalIgnoreCase),
                    Identifier: itemOptions.GetAdditionalTextMetadata(EmbedTextIdentifierMetadataProperty),
                    Enabled: (globalEnabled || itemEnabled) && !itemDisabled,
                    Text: text);
            });

        var enabledTexts = allTexts.Where(e => e.Enabled);

        context.RegisterSourceOutput(enabledTexts, static (context, item) =>
        {
            if (item.Text.GetText() is not { Lines: var lines } text)
                return;

            if (item.ProjectDirectory is not { Length: > 0 })
                throw new InvalidOperationException("No project directory.");
            if (item.Text.Path is not { Length: > 0 })
                throw new InvalidOperationException("Path not found for file.");

            var relativeFolderPath = PathProcessing.GetRelativePath(item.ProjectDirectory, Path.GetDirectoryName(item.Text.Path));
            var relativeFilePath = PathProcessing.GetRelativePath(item.ProjectDirectory, item.Text.Path);

            var @namespace = TextProcessing.GetNamespace(item.ItemNamespace is { Length: > 0 }
                ? item.ItemNamespace
                : $"{item.RootNamespace}.{relativeFolderPath}");

            var className = TextProcessing.GetClassName(item.ItemClassName is { Length: > 0 } 
                ? item.ItemClassName
                : Path.GetFileName(item.Text.Path));

            var isConst = item.IsConst is true;
            var modifier = isConst ? "const" : "static";

            var identifierName = TextProcessing.GetClassName(item.Identifier is { Length: > 0 }
                ? item.Identifier
                : "Content");

            var separator = new string('"', 3);
            while (lines.Any(l => l.Text?.ToString().Contains(separator) == true))
                separator += '\"';

            var sourceBuilder = new StringBuilder(text.Length * 2 + lines.Count * 8 + 300);

            sourceBuilder.AppendLine($$"""
            // <auto-generated />

            namespace {{@namespace}};

            public static partial class {{className}}
            {
                /// <summary>
                /// Contents of the file at '{{relativeFilePath}}':
                /// <code>
            """);

            foreach (var line in lines.Take(10))
            {
                sourceBuilder.AppendLine($$"""
                /// {{line.ToString().Replace("<", "&lt;").Replace(">", "&gt;")}}
            """);
            }
            if (lines.Count > 10)
            {
                sourceBuilder.AppendLine($"/// [{lines.Count - 10} more lines ({lines.Count} total)] ");
            }

            sourceBuilder.AppendLine($$"""
                /// </code>
                /// </summary>
                public {{modifier}} string {{identifierName}} {{(isConst ? "=" : "=>")}} {{separator}}
            {{text}}
            {{separator}};
            }
            """);

            context.AddSource($"{@namespace}/{className}.g.cs", sourceBuilder.ToString());
        });
    }
}
